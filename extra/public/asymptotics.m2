-- Shaowei Lin, 30 Jan 2012
-- Integral Asymptotics
-- Functions:
-- 1. Newton polyhedron of any ideal (not necessarily monomial)
-- 2. tau-distance of any polyhedron
-- 3. face ideals
-- 4. check complex sos nondegeneracy
-- 5. allow user defined real root checking

needsPackage("NormalToricVarieties");
needsPackage("Polyhedra");
needsPackage("Normaliz");
nmzVersion="normbig";
--setNmzOption("bigint",true); 
--setNmzVersion("normbig"); 


-- uses Normaliz
-- adapted from MonomialMultiplierIdeals
newtonPolyhedron = method();
newtonPolyhedron (RingElement) := Polyhedron => (f) -> (
  return newtonPolyhedron ideal f;
);
newtonPolyhedron (Ideal) := Polyhedron => (I) -> (
  R := ring I;
  use R;
  nmzFilename = temporaryFileName() ;
  setNmzOption("supp",true);
  normaliz(matrix((exponentsIdeal I)/exponents/flatten),3); 
  M := readNmzData("sup");
  setNmzOption("normal",true);
  rmNmzFiles();
  n := numColumns M;
  return intersection (-M_{0..(n-2)},M_{n-1});
);

-- once we have computed the Newton polyhedron,
-- we should not have to compute it again to get
-- the tau-distance, so we are not using the 
-- function "monomialThreshold" provided.
tauDistance = method();
tauDistance (Polyhedron, List) := (QQ,Cone) => (P,tau) -> (
  (M,C) := halfspaces P;
  m := numRows M;
  CM := C|M*(transpose matrix {tau/(i->i+1)});
  tauList := (0..m-1)/(j->CM_(j,0)/CM_(j,1));
  tauDist := max tauList;
  tauCone := posHull transpose (-M^(toList select(0..m-1,i->tauList_i==tauDist)));  
  return (tauDist,tauCone);     
);

-- returns the monomial ideal generated by terms
-- appearing in polynomials in an ideal I
exponentsIdeal = method();
exponentsIdeal (Ideal) := MonomialIdeal => (I) -> (
  return monomialIdeal flatten (I_*/terms);
);

-- adapted from MonomialMultiplierIdeal
RLCT = method();
RLCT (RingElement, Thing) := (QQ,ZZ) => (f,m) -> (
  return RLCT(ideal f,m);
);
RLCT (Ideal, ZZ) := (QQ,ZZ) => (I,m) -> (
  R := ring I;
  if m != 0 then (
    return RLCT(I,1_R);
  ) else (
    return RLCT(I,0_R);
  );
);
RLCT (Ideal, RingElement) := (QQ,ZZ) => (I,m) -> (
  J := I;
  if not instance(I,MonomialIdeal) then (
    if not isMonomialIdeal(I) then (
      print("[RLCT] Warning: The given generators of the input ideal are not monomial. Output RLCT is an upper bound. Try using 'gens gb' to see if the input ideal can be generated by monomials.");
    );
    J = exponentsIdeal I;
  );
  if (size(m)!=1) then (
    error("Second input must be a monomial (input was ",m,")");
  ) else (
    (tD,tC) = tauDistance(newtonPolyhedron J, first exponents m);
    return (1/tD,dim tC);
  );
  return 0;
);

faceIdeal = method();
faceIdeal (Ideal, Polyhedron) := Ideal => (I,P) -> (
  return ideal (I_*/(i->facePolynomial(i,P)));
);

facePolynomial = method();
facePolynomial (RingElement, Polyhedron) := RingElement => (f,P) -> (
  return sum select (terms f, i->contains(P,transpose matrix exponents i));
);

sosNondegenerate = method();
sosNondegenerate (Ideal) := (Boolean, List) => (I) -> (
  if instance(I,MonomialIdeal) then return(true,{});
  if isMonomialIdeal(I) then return(true,{});
  I = ideal gens gb I;
  if isMonomialIdeal(I) then return(true,{});
  R := ring I;
  P := newtonPolyhedron I;
  prod := product flatten entries vars R;
  faceList := flatten toList ((1..dim P)/(i->faces(i,P)));
  badFaces := select(faceList, i->if isCompact(i) then (saturate(faceIdeal(I,i),prod)!=ideal(1_R)) else false);
  return (#badFaces==0,badFaces);
);

nondegenerate = method();
nondegenerate (RingElement) := (Boolean, List) => (f) -> (
  R := ring f;
  I := ideal f;
  P := newtonPolyhedron I;
  prod := product flatten entries vars R;
  faceList := flatten toList ((1..dim P)/(i->faces(i,P)));
  badFaces := select(faceList, i->if isCompact(i) then (
    J := faceIdeal(I,i);
    singLocus := ideal(jacobian J)+J;
    saturate(singLocus,prod)!=ideal(1_R)) else false);
  return (#badFaces==0,badFaces);
);

blowupMap = method();
blowupMap(Ring,Cone,List) := 
  (RingMap) => (R,c,sU) -> (
  V := flatten entries vars R;
  M := rays c;
  U := QQ[sU];
  sV := V/(i->toString(i));
  sB := (entries M)/(r->apply(r,sU,(i,j)->value(j|"^"|toString(i))));
  return map(U,R,apply(V,sB,(i,j)->(i=>product(j))));
);

jacobianDeterminant = method();
jacobianDeterminant(RingMap) := (RingElement) => (p) -> (
  return det jacobian matrix p;
);
 
strictTransform = method();
strictTransform(RingElement,List) := Ideal => (f,sU) -> (
  return (strictTransform(ideal f, sU))_0;
);

strictTransform(Ideal,List) := Ideal => (I,sU) -> (
  return saturate (I, product (sU/(i->value(i))));
);

------------------------------------------------
-- FOR MANIPULATING IDEALS WITHOUT TORIC MAPS --
------------------------------------------------
slocus = method();
slocus(RingElement,RingElement) := (Ideal) => (f,E) -> (
  return slocus(ideal f,E);
);
slocus(Ideal,RingElement) := (Ideal) => (I,E) -> (
  V := flatten entries vars ring I;
  V = V/(i->if E%i==0 then i else 1);
  return ideal(diagonalMatrix(V)*(jacobian I))+I;
);

blowupMap(List,String,ZZ) :=
  (RingMap) => (L,se,k) -> (
  R := ring L#0; use R;
  V := flatten entries vars R;
  sa := toString(L#k);
  sL := L/(i->toString(i));
  sV := V/(i->toString(i));
  sU := sV/(si->if si==sa then se else si);
  sB := sV/(si->if si==sa then se else 
    if member(si,sL) then se|"*"|si else si);
  U := QQ[sU];
  p := map(U,R,apply(sB,(j)->value(j)));
  return p;);

-- A configuration F = {I,M,N,A} = {ideal, measure, near, avoid}
-- is a list of ideals in the same ring. 
-- I is the ideal of the variety we are resolving.
-- M is the principal ideal generated by the measure or amplitude function.
-- N is the locus of points near which we are resolving (e.g. the origin).
-- A is the locus of points away from which we don't care (e.g. 1+x^2).
-- A contains units that we can remove from our computations.

-- Takes a list F of ideals,
-- a list L of polynomials to substitute
-- a list A of the old variables to remove
-- a list B of string names for the new variables
-- (old variable names can be reused)
transformConfig = method();
transformConfig(List,List,List,List) :=
  (List) => (F,L,A,BB) -> (
  -- create dummy variable names
  B := apply(toList(0..#BB-1),i->"dummy"|toString(i));
  R := ring F#0; use R;
  rV := flatten entries vars R;
  S := QQ[rV|B]; use S;
  sF := apply(F,i->sub(i,S));
  sL := apply(L,i->sub(i,S));
  sA := apply(A,i->sub(i,S));
  sB := apply(B,i->value(i));
  sJ := ideal apply(toList(0..#sB-1), i->(sL_i-sB_i));
  sF = apply(sF, sI->eliminate(sA, sI+sJ));
  -- change the dummy variable names to the new ones
  tBB := apply(BB,i->toString(i));
  srV := apply(rV,i->sub(i,S));
  trV := srV;
  scan(sA,i->(trV=delete(i,trV)));
  T := QQ[trV|tBB]; use T;
  mapList := apply(trV,i->(sub(i,S)=>sub(i,T)))|
       	     apply(sA,i->(sub(i,S)=>0))|
	     apply(toList(0..#BB-1),i->(sub(sB_i,S)=>value(tBB_i)));
  p := map(T,S,mapList);
  tF := apply(sF,i-> p(i));
  scan(B,i->value(toString(i)|" = symbol "|toString(i)));
  return tF;);

-- This method blows up a configuration F = {I,M,N,A}
-- with respect to a list L of the ring generators 
-- (so we are only doing blowups of linear subspaces).
-- the exceptional divisor will be named by the string se
-- and we only look at the k-th chart of this blowup,
-- where k runs from 0 to (#L - 1).
blowupConfig = method();
blowupConfig(List,List,String,ZZ) := 
  (List) => (F,L,se,k) -> (
  I := F#0; M := F#1; 
  N := F#2; A := F#3; 
  R := ring I;
  p := blowupMap(L,se,k);
  use target p; e := value(se);
  pI := p I; pN := p N; pA := p A;
  pM := (p M)*ideal(e^(#L-1));
  return {pI,pM,pN,pA};);


----------------------------------------------------
-- FOR AUTOMATED RLCT COMPUTATION IN SIMPLE CASES --
----------------------------------------------------

simplifyRegularParameters = method();
simplifyRegularParameters (Ideal) := Ideal => (I) -> (
  R = ring I;
  J = ideal();
  numvar = #(gens R);
  eval0 = map(R,R,toList(numvar:0)); 
  m = eval0 jacobian I;
  scan(1..numvar,i->
    if m^{i-1}!=0 then (
      J = J + ideal((gens R)_(i-1));
      I = eliminate((gens R)_(i-1),I);
      m = eval0 jacobian I;
    ));
  return J+I;
);

removeUnitComponents = method();
removeUnitComponents (Ideal) := Ideal => (I) -> (
  AP = associatedPrimes I;
  scan(AP, i->if (eval0 i)!=0 then I=saturate(I,i));
  return I;
);


----------------------------------
-- FOR HIGHER ORDER ASYMPTOTICS --
----------------------------------

-- helper function.
-- assumes newVar is a list of string
-- m is a column matrix of nonnegative integers
-- m has same number of rows as size of newVar
productString = method();
productString (List, Matrix) := String => (newVars, m) -> (
  d := #newVars;
  if d==0 then
    return "1"
  else 
    return powerString(newVars_0,m_(0,0)) |
    (concatenate ((1..d-1)/(k->"*"|powerString(newVars_k,m_(k,0)))));
);

powerString = method();
powerString (String, Number) := String => (newVar, m) -> (
  return newVar_0|"^"|(if (m<0 or not instance(m,ZZ)) then "("|toString m|")" else toString m);
);

listString = method();
listString (List) := String => (l) -> (
  s := toString toSequence l;
  return substring(s,1,#s-2);
);

isInteger = method();
isInteger (Number) := Boolean => (q) -> (
  if floor(q)==q then
    return true
  else
    return false;
);

toInteger = method();
toInteger (Number) := Number => (q) -> (
  return if floor(mm)==mm then floor(mm) else mm;
);

Dset = method();
Dset (Matrix,ZZ) := List => (m, t) -> (
  D := {};
  d := numRows m;
  intPos := toList select(0..d-1,i->(isInteger(m_(i,0))and(m_(i,0)<=0)));
  for i from t to #intPos do (
    S := subsets(set intPos, i);
    for s in S do ( 
      subD := {-m};
      notS := toList (set(0..d-1)-s);
      for j in notS do (
	posVals := toList (set(0..max(0,floor(1-m_(j,0))))-set{toInteger(-m_(j,0))});
	subD = flatten (subD/(k->(mm:=mutableMatrix k;posVals/(p->(mm_(j,0)=p;matrix mm)))));
      );
      D = D|subD;
    );
  );
  return D;
);

Kset = method();
Kset (Matrix,ZZ) := List => (md, t) -> (
  d := numRows md;
  nonZero := toList select(1..d,i->md_(i-1,0)!=0);
  if d-#nonZero<t then return {};
  subK := {matrix ({{d-#nonZero-t}}|((toList(0..d-1))/(i->if md_(i,0)==0 then {-1} else {0})))};
  K := subK;
  prevIndex := 0;
  for curIndex in nonZero do (
    subKK := subK;
    subK = {};
    for k in subKK do (
      kk := mutableMatrix k;
      r := k_(prevIndex,0);
      subK = subK|(toList ((1..r)/(i->(kk_(curIndex,0)=i;kk_(prevIndex,0)=r-i;matrix kk))));
    );
    K = K|subK;
    prevIndex = curIndex;
  );
  return K;
);

Cvalue = method();
Cvalue (Number,Matrix,Matrix,Matrix) := Number => (theta,valpha,md,k) -> (
  d := numRows md;
  d0 := #select(0..d-1,i->md_(i,0)==0);
  lessZero := toList select(0..d-1,i->md_(i,0)<0);
  return (product toList ((0..d-1)/(i->(valpha_(i,0))^(k_(i+1,0)))))/(d0-theta)!*
    (product (lessZero/(i->(-1)^(k_(i+1,0))*((k_(i+1,0))!)*(md_(i,0))^(-1-k_(i+1,0)))));
);

-- Ivalue = method();
-- Ivalue (Number,Matrix,Matrix,Matrix) := List => (theta,valpha,mm,k) -> (
--   md,mm,newVars,strictTransform
--   dplus := #select(0..d-1,i->md_(i,0)>0);
--   kbar := 
--   mmbar := 
--   mubar := 
--   deltaplus := 
--   changeVars = toString ((0..d-1)/(j->productString(newVars,v_{j})));
--   strictTransform = "g := f"|changeVars|"/("|productString(newVars,v*alpha)|");";
-- );

