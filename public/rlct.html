<HTML>
<body>
<head>
  <title>Ideal-Theoretic Strategies for Asymptotic Approximation of Marginal Likelihood Integrals</title>
</head>

<center>
  <h1>Ideal-Theoretic Strategies for<br> Asymptotic Approximation of<br> Marginal Likelihood Integrals</h1>
  <b><font size="+1">
    <a href="https://w3id.org/people/shaoweilin">Shaowei Lin</a>
 </font></b>
</center>
<br>
<br>
<br>

<h2>Research Paper</h2>

The research paper "Ideal-Theoretic Strategies for Asymptotic Approximation of Marginal Likelihood Integrals" can be found <a href="http://arxiv.org/abs/1003.5338">here</a>.

<h2>Macaulay2 Libraries</h2>

<h3><tt>MonomialMultiplierIdeals</tt> (Zach Teitler)</h3>

Zach Teitler also has a very fast implementation of finding T-distances of
Newton polyhedra. First, install <a href="http://www.math.uiuc.edu/Macaulay2/">Macaulay2</a> on your computer. Next, go to
Zach Teitler's <a href="http://math.boisestate.edu/~zteitler/math/monomialmultiplierideals.php">website</a> to download his MonomialMultiplierIdeals
package and follow his instructions for installing it.<br>
<br>
Here are some examples for computing the T-distance, which should be
self explanatory. <br>
<br>
<tt>R = QQ[x,y2,y3,y4,y5];</tt><br>
<tt>I = monomialIdeal(x*y2,y2^2*y3,y2^2*y4,y2^2*y5);</tt><br>
<tt>monomialThreshold(I,y2^4);</tt><br>
<br>
You should get that the RLCT = 3, and there is a 1x6 matrix following
that output which means the multiplicity equals 1. But one must be
careful: the matrix is a list of hyperplanes meeting at the
intersection point of the tau-diagonal with the Newton polyhedron, so
it is the codimension of this intersection, not the number of
hyperplanes, that gives us the multiplicity. <br>
<br>
Here is another example where the multiplicity is not 1. <br>
<br>
<tt>R = QQ[x,y];</tt><br>
<tt>I = monomialIdeal(x*y);</tt><br>
<tt>monomialThreshold(I,1_R);</tt><br>
<br>
Here, <tt>1_R</tt> stands for the unit in the ring R and the output has a 2x3
matrix, which means that the multiplicity is 2. The RLCT is 1.
<br>

<h3><tt>asymptotics.m2</tt> (Shaowei Lin)</h3>

Download the library <a href="asymptotics.m2">asymptotics.m2</a>. The
RLCT (exact for monomial ideals, upper bound otherwise) can be
computed using the following code.<br>
<br>
<tt>load "asymptotics.m2";</tt><br>
<tt>R = QQ[x,y2,y3,y4,y5];</tt><br>
<tt>I = ideal(x*y2,y2^2*y3,y2^2*y4,y2^2*y5);</tt><br>
<tt>RLCT(I,1)</tt><br>
<tt>RLCT(I,y2^4)</tt><br>
<br>
The <tt>RLCT(I,m)</tt> function computes the reciprocal of the tau-distance
of the Newton polyhedron of the ideal <tt>I</tt>, where tau is the exponents of the monomial <tt>m</tt>. Thus, if the input ideal is a monomial, the
output is precisely the RLCT; otherwise, it is only an upper bound. To
check if your input ideal can be generated by monomials, try the
following command to compute the Grobner basis. If the ideal is
monomial, then the Grobner basis will be a list of monomials.<br>
<br>
<tt>gens gb I</tt><br>
<br>
The function <tt>newtonPolyhedron(I)</tt> returns the Newton polyhedron
of the input ideal. It uses the object type <tt>Polyhedron</tt> from
the Macaulay2 package <tt>Polyhedra</tt>. For polynomials <tt>f</tt>,
the function <tt>newtonPolyhedron(f)</tt> returns the Newton polyhedron
of <tt>f</tt>.<br>
<br>
<tt>P = newtonPolyhedron I</tt><br>
<br>
The function <tt>tauDistance(P,t)</tt> computes the tau-distance of
the polyhedron <tt>P</tt> where tau is given by the list <tt>t</tt> of
integers. Here, the tau-distance is defined to be the smallest
rational number <tt>s</tt> such that the point <tt>s(t+1)</tt> lies in
<tt>P</tt>. The function returns a pair <tt>(l,Q)</tt> where <tt>l</tt> is the
tau-distance and <tt>Q</tt> is the tau-cone, i.e. the cone dual to the
face of the polyhedron <tt>P</tt> at the intersection of the
tau-diagonal with <tt>P</tt>. The dimension of <tt>Q</tt> is the
multiplicity of the tau-distance.<br>
<br>
<tt>(l,Q) = tauDistance(P,{0,0,0,0,0})</tt><br>
<tt>dim Q</tt><br>
<br>
The function <tt>exponentsIdeal(I)</tt> returns the <tt>MonomialIdeal</tt>
generated by terms appearing in polynomials <tt>f</tt> in the input ideal.<br>
<br>
<tt>exponentsIdeal(I)</tt><br>
<br>
The function <tt>faceIdeal(I,Q)</tt> returns
the face ideal of the ideal <tt>I</tt> at a face polyhedron <tt>Q</tt>, while
the function <tt>facePolynomial(f,Q)</tt> returns
the face polynomial of the polynomial <tt>f</tt> at the face
polyhedron <tt>Q</tt>. <br>
<br>
<tt>Q = (faces(1,P))_0</tt><br>
<tt>f = x*y2+y2^2*y3</tt><br>
<tt>facePolynomial(f,Q)</tt><br>
<tt>faceIdeal(I,Q)</tt><br>
<br>
The function <tt>sosNondegenerate(I)</tt> checks if the ideal
<tt>I</tt> is sos-nondegenerate. It returns a pair <tt>(b,L)</tt>
where <tt>b</tt> is boolean and <tt>L</tt> is a list of faces of the
Newton polyhedron</tt>. If <tt>b==true</tt>, then the input ideal is
sos-nondegenerate. If <tt>b==false</tt>, then the function was not
able to determinine for sure if the ideal is sos-nondegenerate. Recall that an ideal <tt>I</tt> is
sos-nondegenerate if for all compact faces <tt>Q</tt> of the Newton
polyhedron <tt>P</tt> of <tt>I</tt>, the real variety of the face
ideal <tt>I_Q</tt> does not intersect the real torus <tt>(R^*)^d</tt>
where <tt>d</tt> is the number of variables in the base ring. Because
we do not have efficient algorithms for checking if a real variety is
empty, the implemented function first checks if the ideal is
monomial. If it is monomial, it returns that the ideal is
sos-nondegenerate. Otherwise, for each compact face <tt>Q</tt> of the
Newton polyhedron, it saturates the face ideal <tt>I_Q</tt> with the
product of the ring variables to remove components of the (complex)
variety that lies completely in the coordinate hyperplanes. If all the
resulting saturation ideals are the unit ideal, then the function
returns that the ideal is sos-nondegenerate. Otherwise, it returns a
list <tt>L</tt> of "bad faces" <tt>Q</tt> where the function could not
determinine if the real variety of <tt>I_Q</tt> intersects the
torus. This function can be slow, even for simple
examples, because saturating ideals is computationally intensive.<br>
<br>
<tt>(b,L) = sosNondegenerate I</tt><br>
<br>
To find the face ideal corresponding to the 0-th bad face, we can use
the following code where we saturate out the coordinate hyperplanes to
find roots in the torus.<br>
<br>
<tt>J = faceIdeal(I, L#0)</tt><br>
<tt>saturate (J, product flatten entries vars ring I)</tt><br>
<br>
The function <tt>nondegenerate(f)</tt> checks if the polynomial
<tt>f</tt> is nondegenerate. That means that it runs through all the
compact faces of the Newton polyhedron of <tt>f</tt>, computes the
face polynomial of <tt>f</tt> at that face, and checks if the singular
locus is empty in the torus. If all these singular loci are empty,
then <tt>f</tt> is nondegenerate. As with <tt>sosNondegenerate</tt>,
it returns a pair <tt>(b,L)</tt> where the boolean <tt>b</tt> states
if <tt>f</tt> is nondegenerate and the list <tt>L</tt> contains all
the "bad faces".<br>
<br>
<tt>(b,L) = nondegenerate f</tt><br>
<br>
The function <tt>slocus(I,e)</tt> computes the ideal of the singular locus of the
ideal <tt>I</tt> with respect to the exceptional divisor defined by
<tt>e = 0</tt> where <tt>e</tt> is a ring variable. This singular locus ideal is generated by generators
<tt>f</tt> of <tt>I</tt>, partial derivatives <tt>df/dx</tt> for
each non-exceptional variable <tt>x</tt> and <tt>e(df/de)</tt> for the
exceptional variable <tt>e</tt>.<br>
<br>
The function <tt>blowupMap(R,c,L)</tt> returns a ring map that blows
up the origin of the ring <tt>R</tt> with respect to the
full-dimensional simplicial cone <tt>c</tt>. The list <tt>L</tt> is
a list of strings that will be used as names for the new variables in
the blowup ring.<br>
<br>
The function <tt>strictTransform(I,L)</tt> saturates out the
coordinate hyperplanes corresponding to the variables in the list
<tt>L</tt>. The list <tt>L</tt> can be a list of variables or a list
of strings that are names of the variables.<br>
<br>
The function <tt>jacobianDeterminant(p)</tt> returns the Jacobian
determinant of the ring map <tt>p</tt>.<br>
<br>
The following code computes the Newton polyhedron of
the ideal I and finds a smooth refinement of its normal fan. It then
selects the 0-th cone in that smooth fan, and blows up the ideal using
the corresponding blowup map. It also computes the Jacobian
determinant of the map and the strict transform of the ideal.<br>
<br>
<tt>P = newtonPolyhedron I;</tt><br>
<tt>T = normalToricVariety P;</tt><br>
<tt>S = makeSmooth T;</tt><br>
<tt>F = fan S;</tt><br>
<tt>C = cones (dim F,F);</tt><br>
<tt>U = {"e1","e2","e3","e4","e5","e6"};</tt><br>
<tt>p = blowupMap(ring I, C#0, U);</tt><br>
<tt>pI = p I</tt><br>
<tt>jacobianDeterminant(p)</tt><br>
<tt>strictTransform(pI, U)</tt><br>
<br>
The function <tt>simplifyRegularParameters(I)</tt> computes an ideal
whose RLCT is equal to that of the input ideal <tt>I</tt>. What it
does is that it evaluates at the origin the Jacobian matrix of the generators of the
ideal, and looks for ring variables that has a nonzero row in the
matrix. We can then project the variety of the ideal to the hyperplane
defined by this ring variable, and the image will have
the same RLCT modulo the dimension lost from the projection. In terms of ideals, this corresponds to eliminating the
above ring variable from the ideal. After running through all the
variables, we add the eliminated variables to the resulting ideal to
get an ideal that has the same RLCT as the original ideal. The
following example demonstrates this idea.<br>
<br>
<tt>restart;</tt><br>
<tt>load "asymptotics.m2";</tt><br>
<tt>R = QQ[t,a1,a2,b1,b2,c1,c2,d1,d2];</tt><br>
<tt>A = matrix {{a1,a2,1-a1-a2}};</tt><br>
<tt>B = matrix {{b1,b2,1-b1-b2}};</tt><br>
<tt>C = matrix {{c1,c2,1-c1-c2}};</tt><br>
<tt>D = matrix {{d1,d2,1-d1-d2}};</tt><br>
<tt>P = t*(transpose A)*B + (1-t)*(transpose C)*D;</tt><br>
<tt>shift = map(R,R,{t+1/2,a1+1/3,a2+1/3,b1+1/3,b2+1/3,c1+1/3,c2+1/3,d1+1/3,d2+1/3});</tt><br>
<tt>eval = map(R,R,{1/2,1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3});</tt><br>
<tt>I = ideal (shift P - eval P)</tt><br>
<tt>I1 = simplifyRegularParameters I</tt><br>
<br>
The function <tt>removeUnitComponents(I)</tt> is another function that
can help simplify the ideal for which we are trying to compute the
RLCT at the origin. It removes components of the variety of the
ideal which are not passing through the origin. In terms of ideals, it
looks for associated primes of the input ideal which do not evaluate
to zero at the origin, and saturates the ideal
by these primes. Below, we continue from the above example. Note that
at the end, we get a monomial ideal for which we can compute the RLCT.<br>
<br>
<tt>associatedPrimes I1</tt><br>
<tt>I2 = removeUnitComponents I1</tt><br>
<tt>associatedPrimes I2</tt><br>
<tt>RLCT(I2,1)</tt><br>
<br>
Alternatively, one can use the software <tt>Singular</tt> to remove units, such as
<tt>1-2*t</tt> in the previous example, from the
ideal in the local ring at the origin. Mora's algorithm for standard
bases, which is implemented in <tt>Singular</tt>, should do the
job. Here is the sample code in <tt>Singular</tt> for the previous
example.<br>
<br>
<tt>ring R = 0,(t,a1,a2,b1,b2,c1,c2,d1,d2),ds;</tt><br>
<tt>ideal I = a1,a2,b1,b2,</tt><br>
<tt>2*t*c2*d2-c2*d2,2*t*c1*d2-c1*d2,</tt><br>
<tt>2*t*c2*d1-c2*d1,2*t*c1*d1-c1*d1;</tt><br>
<tt>groebner(I);</tt><br>
<br>
The code produces the following output.<br>
<br>
<tt>_[1]=a1 </tt><br>
<tt>_[2]=a2 </tt><br>
<tt>_[3]=b1 </tt><br>
<tt>_[4]=b2 </tt><br>
<tt>_[5]=c1*d1 </tt><br>
<tt>_[6]=c2*d1 </tt><br>
<tt>_[7]=c1*d2 </tt><br>
<tt>_[8]=c2*d2 </tt><br>
<br>

<h2>Singular Library</h2>

You should have <a
href="http://www.math.tu-berlin.de/~jensen/software/gfan/gfan.html"><tt>GFan</tt></a>
and <a href="http://www.polymake.de"><tt>Polymake</tt></a> installed on your
system.<br>
<br>
The <tt>Singular</tt> library can be downloaded here: <a
href="rlct.lib">rlct.lib</a>. You will also need the library <a href=
"http://www.mathematik.uni-kl.de/~keilen/download/Tropical/polymake.lib">polymake.lib</a>.
<br>
<br>
Put both files in your work directory and type the command<br>
<br>
<tt>LIB "rlct.lib";</tt><br>
<br>
when you start your <tt>Singular</tt> session. <br>
<br>
The above library should work with <tt>Polymake</tt> version 2.9 and
above. If you are using <tt>Polymake</tt> version 2.3, use this instead: <a
href="rlct0.lib">rlct0.lib</a>. After downloading the file, remember to change its name to <tt>rlct.lib</tt>.

<h2>Functions</h2>

The command<br>
<br>
<tt>list L = ndg(f);</tt><br>
<br>
determines if a
polynomial <tt>f</tt> is nondegenerate. The list <tt>L</tt> contains information
about the Newton polyhedron of <tt>f</tt>.
<ol>
<li>
integer with value 1 if f is nondegenerate and 0 otherwise *
</li>
<li>
exponents of highest common monomial dividing f  
</li>
<li>
f-vector of Newton polyhedron G of f
</li>
<li>
weight vectors for faces (non-vertices) of G
</li>
<li>
inequalities defining G                              
</li>
<li>
faces of G and the facets which meet them
</li>
<li>
polynomial Lf of lowest terms of f
</li>
<li>
dimension of Newton polytope of Lf 
</li>
<li>
vertices of Newton polytope of Lf
</li>
<li>
if f is degenerate, a weight vector w giving a bad face
</li>
<li>
if f is degenerate, the initial form w.r.t. w
</li>
</ol>
* The software currently checks nondegeneracy by checking the existence of complex roots, rather than the existence of real roots. This is because we do not know of any good libraries for real root computations. Thus, if <tt>L[1] = 1</tt>, then <tt>f</tt> is definitely nondegenerate, but if <tt>L[1] = 0</tt>, we are unsure of the nondegeneracy of <tt>f</tt>.
<br>
<br>
For an ideal <tt>I</tt>, use the command<br>
<br>
<tt>list L = sosndg(I);</tt><br>
<br>
It returns a list <tt>L</tt> with 11 items as before, and it will contain information about the Newton polyhedron of <tt>I</tt>. Items 7 to 11 will be information about the sum of squares <tt>f</tt> of the given generators of <tt>I</tt>. If <tt>I</tt> is a monomial ideal, the software detects that and sets <tt>L[1] = 1</tt>. If <tt>I</tt> is not a monomial ideal, the software checks if the sum of squares <tt>f</tt> is nondegenerate. Right now, the software does not check if the ideal is sos-nondegenerate.<br><br>

The command<br>
<br>
<tt>rlct(L);</tt><br>
<br>
returns <tt>(1/l, t)</tt> where <tt>l</tt> is the distance of the
Newton polyhedron of <tt>f</tt> or of the ideal <tt>I</tt> and <tt>t</tt> its multiplicity. If
<tt>f</tt> is nondegenerate or if <tt>I</tt> is monomial or nondegenerate, this is precisely the real log canonical
threshold of <tt>f</tt> or <tt>I</tt>.<br><br>

To find the distance in the direction of some non-negative vector <tt>T+1</tt>, use the command<br>
<br>
<tt>rlct(L, T);</tt><br>
<br>
The default value of <tt>T</tt> is the zero vector. For instance, if the ring has 3 variables and we want to find the distance in the direction (1+1, 2+1, 3+1), we type<br>
<br>
<tt>rlct(L, intvec(1,2,3));</tt><br>
<br>
<br>
<br>
<h2>Examples</h2>


<tt>LIB "rlct.lib";<br>
<br>
ring RR = 0, (x,y,z), ds;<br>
poly f = (x*y)^2+(y*z)^2+(x*z)^2;<br>
list L = ndg(f);<br>
if (L[1]==1) <br>
{<br>
&nbsp&nbsp  print ("The polynomial is nondegenerate.");<br>
&nbsp&nbsp  print ("The RLCT is");<br>
&nbsp&nbsp  print (rlct(L));<br>
}<br>
else <br>
{<br>
&nbsp&nbsp  print ("The polynomial may be degenerate.");<br>
&nbsp&nbsp  print ("One face polynomial that is singular in the torus is");<br>
&nbsp&nbsp  print (L[11]);<br>
}
</tt>
<br>
<br>
<h2>Suggestions and Bugs</h2>

If you find any bugs in the code or have any comments or suggestions, please do not hesitate to contact Shaowei Lin. His email address is<br>
<br>
<tt>shaowei [underscore] lin [dot] sutd [dot] edu [dot] sg</tt><br>
<br>
<br>
<br>

<SCRIPT LANGUAGE="Javascript"><!--
var m = document.lastModified;
var p = m.length-12;
document.write("Last Updated: "+m);
//--></SCRIPT>

</body>
</HTML>
